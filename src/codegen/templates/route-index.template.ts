import type { ParsedResource, ParsedField } from '../utils/schema-parser'

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

function formatLabel(s: string): string {
  return capitalize(s.replace(/_/g, ' '))
}

export function generateRouteIndex(resource: ParsedResource): string {
  const { config, fields } = resource
  const { name, pluralName, table, search, dataSource } = config
  const typeName = capitalize(name)
  const displayName = capitalize(pluralName)

  // Get columns from config or default to all non-hidden fields
  const searchableFields = table?.searchableFields ?? search?.searchableFields ?? []
  const filterableFields = table?.filterableFields ?? []
  const defaultSort = table?.defaultSort ?? { field: 'created_at', order: 'desc' }

  // Generate parquet-backed route
  if (dataSource === 'parquet') {
    return generateParquetRouteIndex({
      name,
      pluralName,
      typeName,
      displayName,
      searchableFields,
      filterableFields,
      defaultSort,
      description: config.description,
      analyticsEnabled: config.analytics?.enabled ?? false,
      fields,
    })
  }

  // Default: JSON/TanStack DB route
  return generateJsonRouteIndex({
    name,
    pluralName,
    typeName,
    displayName,
    searchableFields,
    filterableFields,
    defaultSort,
    description: config.description,
    fields,
  })
}

type RouteIndexParams = {
  name: string
  pluralName: string
  typeName: string
  displayName: string
  searchableFields: string[]
  filterableFields: string[]
  defaultSort: { field: string; order: string }
  description?: string
  analyticsEnabled?: boolean
  fields: ParsedField[]
}

/**
 * Generate route for JSON/TanStack DB data source (existing behavior)
 */
function generateJsonRouteIndex(params: RouteIndexParams): string {
  const { name, pluralName, typeName, displayName, searchableFields, filterableFields, defaultSort, description, fields } = params

  // Get the first filterable field for tabs (usually 'status')
  const tabField = filterableFields[0]
  const tabFieldData = tabField ? fields.find(f => f.name === tabField) : null
  const hasTabField = !!tabFieldData

  // Get other filterable fields for faceted filters
  const facetedFields = filterableFields.slice(1)

  // Build tab config
  const tabConfigCode = hasTabField ? `
const tabConfig = {
  column: '${tabField}',
  options: ${tabField}Options.map(opt => ({ value: opt, label: formatLabel(opt) })),
}` : ''

  // Build filter configs
  const filterConfigsCode = facetedFields.length > 0 ? `
const filterConfigs = [
${facetedFields.map(f => `  {
    column: '${f}',
    title: '${formatLabel(f)}',
    options: ${f}Options.map(opt => ({ value: opt, label: formatLabel(opt) })),
  }`).join(',\n')}
]` : 'const filterConfigs: FilterConfig[] = []'

  // Collect all enum imports needed
  const enumImports = filterableFields.map(f => `${f}Options`).join(', ')

  return `// ðŸ”„ GENERATED by codegen

import { createFileRoute, Link, useNavigate } from '@tanstack/react-router'
import { z } from 'zod'
import { useLiveQuery } from '@tanstack/react-db'
import { IconPlus } from '@tabler/icons-react'
import { ${pluralName}Collection } from '@/collections'
import { ${name}Columns } from '@/components/tables/${name}-columns'
import { DataTableFull, type FilterConfig } from '@/components/shared/data-table-full'
import { Button } from '@/components/ui/button'
import { ${enumImports} } from '@/schemas/${name}.schema'

// Helper to format enum values as labels
function formatLabel(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1).replace(/_/g, ' ')
}
${tabConfigCode}
${filterConfigsCode}

const searchParamsSchema = z.object({
  search: z.string().optional(),
  sort: z.string().default('${defaultSort.field}'),
  order: z.enum(['asc', 'desc']).default('${defaultSort.order}'),
})

export const Route = createFileRoute('/_app/${pluralName}/')({
  validateSearch: searchParamsSchema,
  component: ${displayName}IndexPage,
})

function ${displayName}IndexPage() {
  const globalNavigate = useNavigate()

  // Live query from TanStack DB
  const { data: items = [], isLoading } = useLiveQuery((q) => {
    return q.from({ item: ${pluralName}Collection })
  })

  const handleRowClick = (row: (typeof items)[0]) => {
    globalNavigate({ to: '/${pluralName}/$id/edit', params: { id: row.id } })
  }

  return (
    <div className="@container/main flex flex-col gap-6">
      {/* Header */}
      <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
        <div>
          <h1 className="text-2xl font-semibold tracking-tight">${displayName}</h1>
          <p className="text-muted-foreground text-sm">${description ?? `Manage your ${pluralName}`}</p>
        </div>
        <Button asChild>
          <Link to="/${pluralName}/new">
            <IconPlus className="mr-2 h-4 w-4" />
            New ${typeName}
          </Link>
        </Button>
      </div>

      {/* Table with all features */}
      <DataTableFull
        columns={${name}Columns}
        data={items}
        isLoading={isLoading}
        onRowClick={handleRowClick}
        searchColumn="${searchableFields[0] ?? 'id'}"
        searchPlaceholder="Search ${pluralName}..."
        ${hasTabField ? 'tabConfig={tabConfig}' : ''}
        filterConfigs={filterConfigs}
        showColumnVisibility
        showRowSelection
        showPagination
        headerActions={
          <Button asChild>
            <Link to="/${pluralName}/new">
              <IconPlus className="mr-2 h-4 w-4" />
              <span className="hidden sm:inline">New ${typeName}</span>
            </Link>
          </Button>
        }
      />
    </div>
  )
}
`
}

/**
 * Generate route for parquet/DuckDB data source (windowed loading)
 */
function generateParquetRouteIndex(params: RouteIndexParams): string {
  const { name, pluralName, typeName, displayName, searchableFields, defaultSort, description, analyticsEnabled } = params

  // Build search field conditions for SQL WHERE clause
  const searchConditions = searchableFields.length > 0
    ? searchableFields.map(f => `LOWER(COALESCE(${f}, '')) LIKE LOWER('%' || \${escaped} || '%')`).join(' OR ')
    : `LOWER(COALESCE(id, '')) LIKE LOWER('%' || \${escaped} || '%')`

  const iconImports = analyticsEnabled ? 'IconPlus, IconSearch, IconChartBar' : 'IconPlus, IconSearch'

  return `// ðŸ”„ GENERATED by codegen - parquet/DuckDB data source

import { useState, useEffect, useCallback } from 'react'
import { createFileRoute, Link, useNavigate } from '@tanstack/react-router'
import { z } from 'zod'
import { ${iconImports} } from '@tabler/icons-react'
import { use${typeName}WindowedQuery, build${typeName}Where, type ${typeName} } from '@/collections/${pluralName}.collection'
import { ${name}Columns } from '@/components/tables/${name}-columns'
import { DataTableVirtualDynamic } from '@/components/shared/data-table-virtual-dynamic'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'

const searchParamsSchema = z.object({
  search: z.string().optional(),
  sort: z.string().default('${defaultSort.field}'),
  order: z.enum(['asc', 'desc']).default('${defaultSort.order}'),
})

export const Route = createFileRoute('/_app/${pluralName}/')({
  validateSearch: searchParamsSchema,
  component: ${displayName}IndexPage,
})

function ${displayName}IndexPage() {
  const routeNavigate = Route.useNavigate()
  const globalNavigate = useNavigate()
  const { search, sort, order } = Route.useSearch()
  const [totalCount, setTotalCount] = useState(0)
  const [isLoadingCount, setIsLoadingCount] = useState(true)

  // Build WHERE clause from search params
  const whereClause = build${typeName}Where({ search })
  const orderByClause = \`\${sort} \${order.toUpperCase()}\`

  // Windowed query hook for on-demand row fetching
  const { fetchRows, getTotalCount } = use${typeName}WindowedQuery({
    where: whereClause,
    orderBy: orderByClause,
  })

  // Fetch total count when filters change
  useEffect(() => {
    setIsLoadingCount(true)
    getTotalCount()
      .then(setTotalCount)
      .finally(() => setIsLoadingCount(false))
  }, [getTotalCount, whereClause])

  const handleRowClick = useCallback((row: ${typeName}) => {
    globalNavigate({ to: '/${pluralName}/$id/edit', params: { id: row.id } })
  }, [globalNavigate])

  return (
    <div className="flex flex-col gap-6">
      {/* Header */}
      <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
        <div>
          <h1 className="text-2xl font-semibold tracking-tight">${displayName}</h1>
          <p className="text-muted-foreground text-sm">${description ?? `Manage your ${pluralName}`}</p>
        </div>
        <div className="flex gap-2">
          ${analyticsEnabled ? `<Button variant="outline" asChild>
            <Link to="/${pluralName}/analytics">
              <IconChartBar className="mr-2 h-4 w-4" />
              Analytics
            </Link>
          </Button>` : ''}
          <Button asChild>
            <Link to="/${pluralName}/new">
              <IconPlus className="mr-2 h-4 w-4" />
              New ${typeName}
            </Link>
          </Button>
        </div>
      </div>

      {/* Search */}
      <div className="flex items-center gap-4">
        <div className="relative flex-1 max-w-sm">
          <IconSearch className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search ${pluralName}..."
            value={search ?? ''}
            onChange={(e) =>
              routeNavigate({
                search: (prev) => ({
                  ...prev,
                  search: e.target.value || undefined,
                }),
              })
            }
            className="pl-9"
          />
        </div>
      </div>

      {/* Table */}
      <DataTableVirtualDynamic
        columns={${name}Columns}
        totalCount={totalCount}
        fetchRows={fetchRows}
        isLoading={isLoadingCount}
        onRowClick={handleRowClick}
        maxHeight="calc(100vh - 280px)"
      />
    </div>
  )
}
`
}
