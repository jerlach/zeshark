import type { ParsedResource } from '../utils/schema-parser'

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

export function generateCollection(resource: ParsedResource): string {
  const { config } = resource
  const { name, pluralName } = config
  const typeName = capitalize(name)
  const apiPath = config.apiBasePath ?? `/api/${pluralName}`

  return `// ðŸ”„ GENERATED by codegen - modifications may be overwritten

import { createCollection } from '@tanstack/db'
import { queryCollectionOptions } from '@tanstack/query-db-collection'
import { apiClient } from '@/api/client'
import { queryClient } from '@/lib/query-client'
import type { ${typeName} } from '@/schemas/${name}.schema'

/**
 * ${typeName} collection - fetches from API via TanStack Query.
 * Data is cached locally and supports optimistic mutations.
 */
export const ${pluralName}Collection = createCollection<${typeName}, string>(
  queryCollectionOptions({
    queryClient,
    queryKey: ['${pluralName}'],
    queryFn: async () => {
      const response = await apiClient.get<${typeName}[]>('${apiPath}')
      return response.data
    },
    getKey: (item) => item.id,

    // Mutation handlers - send changes to API
    onInsert: async ({ transaction }) => {
      const item = transaction.mutations[0].modified
      await apiClient.post('${apiPath}', item)
    },
    onUpdate: async ({ transaction }) => {
      const { original, modified } = transaction.mutations[0]
      await apiClient.patch(\`${apiPath}/\${original.id}\`, modified)
    },
    onDelete: async ({ transaction }) => {
      const { original } = transaction.mutations[0]
      await apiClient.delete(\`${apiPath}/\${original.id}\`)
    },
  })
)

export type { ${typeName} }
`
}
