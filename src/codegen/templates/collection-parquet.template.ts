import type { ParsedResource } from '../utils/schema-parser'

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

/**
 * Generate a parquet-backed collection hook.
 * Instead of TanStack DB collection, this generates a custom hook that uses
 * DuckDB WASM to query parquet files.
 */
export function generateCollectionParquet(resource: ParsedResource): string {
  const { config } = resource
  const { name, pluralName } = config
  const typeName = capitalize(name)
  const apiPath = config.apiBasePath ?? `/${pluralName}`

  return `// ðŸ”„ GENERATED by codegen - parquet-backed collection
// Uses DuckDB WASM for querying parquet files

import { useWindowedQuery, useDuckDBQuery } from '@/hooks/use-duckdb-query'
import type { ${typeName} } from '@/schemas/${name}.schema'

const API_BASE = import.meta.env.VITE_API_URL ?? 'http://localhost:3000'
const PARQUET_URL = \`\${API_BASE}${apiPath}\`

/**
 * Hook for querying ${pluralName} from parquet with pagination.
 * Use this for standard list views with pagination controls.
 */
export function use${typeName}Query(options?: {
  where?: string
  orderBy?: string
  page?: number
  pageSize?: number
  enabled?: boolean
}) {
  return useDuckDBQuery<${typeName}>({
    queryKey: ['${pluralName}'],
    baseUrl: PARQUET_URL,
    where: options?.where,
    orderBy: options?.orderBy ?? 'created_at DESC',
    page: options?.page ?? 0,
    pageSize: options?.pageSize ?? 100,
    enabled: options?.enabled ?? true,
  })
}

/**
 * Hook for windowed/virtual scroll queries.
 * Use this for large datasets with infinite scroll / virtual tables.
 */
export function use${typeName}WindowedQuery(options?: {
  where?: string
  orderBy?: string
}) {
  return useWindowedQuery<${typeName}>({
    queryKey: ['${pluralName}'],
    baseUrl: PARQUET_URL,
    where: options?.where,
    orderBy: options?.orderBy ?? 'created_at DESC',
  })
}

/**
 * Build a SQL WHERE clause from filter parameters.
 * Sanitizes inputs to prevent SQL injection.
 */
export function build${typeName}Where(filters: {
  search?: string
  status?: string
  // Add more filter fields as needed
}): string | undefined {
  const conditions: string[] = []

  if (filters.search) {
    // Escape single quotes for SQL
    const escaped = filters.search.replace(/'/g, "''")
    // Search across common text fields - customize per resource
    conditions.push(\`(
      LOWER(COALESCE(reference, '')) LIKE LOWER('%\${escaped}%') OR
      LOWER(COALESCE(id, '')) LIKE LOWER('%\${escaped}%')
    )\`)
  }

  if (filters.status) {
    const escaped = filters.status.replace(/'/g, "''")
    conditions.push(\`status = '\${escaped}'\`)
  }

  return conditions.length > 0 ? conditions.join(' AND ') : undefined
}

// Re-export type for convenience
export type { ${typeName} }
`
}
